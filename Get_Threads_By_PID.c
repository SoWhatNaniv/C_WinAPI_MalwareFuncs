#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <tchar.h>


// Get threads that belong to a specific pid
// Using Thread32First/Thread32Next
// We take a snapshout of our system and iterate over the threads to find our's
// Make a snapshot of the system using CreateToolHelp32Snapshot
THREADENTRY32* find_all_pids_threads(int* pid_arr) {


	int* pid = pid_arr;
	THREADENTRY32* temp_thread_arr;
	int thread_count = 1;
	THREADENTRY32* thread_arr = (THREADENTRY32*)calloc(thread_count, sizeof(THREADENTRY32)); // Thread Pointers Array
	if (!thread_arr) {
		exit(1);
	}

	HANDLE handleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);

	if (handleSnapshot == INVALID_HANDLE_VALUE) {
		printf("Can't create a snapshot of the current system\r\n");
		return 1;
	}

	// Allocate struct for threads iterating
	THREADENTRY32* ptrThread = (THREADENTRY32*)calloc(1, sizeof(THREADENTRY32));
	ptrThread->dwSize = sizeof(THREADENTRY32);

	while (*pid != 0) {

		if (Thread32First(handleSnapshot, ptrThread) != TRUE) {
			printf("Cannot get first thread \n");
			return 1;
		}
		do {
			// If the thread PID is equal to PID, add to list
			if (ptrThread->th32OwnerProcessID == *pid) {
				thread_arr[thread_count - 1] = *ptrThread;
				thread_count++;
				temp_thread_arr = (THREADENTRY32*)realloc(thread_arr, thread_count * sizeof(THREADENTRY32));
				if (!temp_thread_arr) {
					exit(1);
				}
				thread_arr = temp_thread_arr;
			}
		} while (Thread32Next(handleSnapshot, ptrThread) == TRUE);
		pid++;
	}

	thread_arr[thread_count - 1].th32ThreadID = 0; // end of threads array

	return thread_arr;
}
