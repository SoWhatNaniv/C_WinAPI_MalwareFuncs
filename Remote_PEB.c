#include <windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <psapi.h>
#include <stdio.h>

typedef NTSTATUS(__stdcall* QueryInformationProcessFunc)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

HINSTANCE ntdllInstance;
QueryInformationProcessFunc NtQueryInformationProc;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	PVOID Handle;
} CURDIR, * PCURDIR;
typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	WORD Flags;
	WORD Length;
	ULONG TimeStamp;
	STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;
typedef struct __RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;
	ULONG Flags;
	ULONG DebugFlags;
	PVOID ConsoleHandle;
	ULONG ConsoleFlags;
	PVOID StandardInput;
	PVOID StandardOutput;
	PVOID StandardError;
	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;
	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;
	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];
	ULONG EnvironmentSize;

} RTL_USER_PROCESS_PARAMETERSs;
typedef struct LoadedModuleData_ {
	struct LoadedModuleData_* Next;
	struct LoadedModuleData_* Previous;
	LIST_ENTRY InMemoryOrderLinks;
	void** DllBase;
	DWORD* UnknowAdressInDLL; // may be start address
	DWORD* UnKnown2;
	UNICODE_STRING FullDllPath;
	UNICODE_STRING DllName;
} LoadedModuleData;

int find_pid(char* procName) {
	int pid = NULL;

	HANDLE handleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (handleSnapshot == INVALID_HANDLE_VALUE) {
		wprintf(L"Can't create a snapshot of the current system\r\n");
		return 1;
	}

	PROCESSENTRY32 processEntry = { 0 };
	processEntry.dwSize = sizeof(processEntry);

	if (Process32First(handleSnapshot, &processEntry)) {
		do {
			if (wcscmp(processEntry.szExeFile, procName) == 0) {
				pid = processEntry.th32ProcessID;
			}
		} while (Process32Next(handleSnapshot, &processEntry));
	}

	CloseHandle(handleSnapshot);
	return pid;
}

void print_peb(int pid) {

	NtQueryInformationProc = (QueryInformationProcessFunc)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryInformationProcess");

	int bytesRead;
	PROCESS_BASIC_INFORMATION info;
	PEB pPEB;
	RTL_USER_PROCESS_PARAMETERSs Rtl;

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProcess == NULL) {
		exit(1);
	}
	NTSTATUS status = NtQueryInformationProc(hProcess, ProcessBasicInformation, &info, sizeof(info), NULL);
	if (!NT_SUCCESS(status)) {
		exit(1);
	}

	printf("PEB base address: 0x%p\n", info.PebBaseAddress);
	ReadProcessMemory(hProcess, info.PebBaseAddress, &pPEB, sizeof(PEB), &bytesRead);
	printf("Being debugged: %d\n", pPEB.BeingDebugged);
	printf("\n");

	LoadedModuleData* LoadedModules = (LoadedModuleData*)*((void**)((DWORD)pPEB.Ldr->InMemoryOrderModuleList.Flink));
	printf("Loaded Modules:\n");
	do {
		wprintf(L"%s 0x%p\n", LoadedModules->FullDllPath.Buffer, LoadedModules->DllBase);
		LoadedModules = LoadedModules->Next;
	} while (LoadedModules->DllBase);
	wprintf(L"\n");

	ReadProcessMemory(hProcess, pPEB.ProcessParameters, &Rtl, sizeof(Rtl), &bytesRead);

	wchar_t* env = (wchar_t*)malloc(sizeof(wchar_t) * Rtl.EnvironmentSize);
	if (!env) {
		exit(1);
	}
	wprintf(L"Env Vars:\n");
	ReadProcessMemory(hProcess, Rtl.Environment, env, Rtl.EnvironmentSize, &bytesRead);

	for (int i = 0; i < Rtl.EnvironmentSize; i++) {
		if (env[i] == '\0') {
			if (env[i + 1] == '\0') {
				wprintf(L"\n");
				break;
			}
			wprintf(L"\n");
		}
		wprintf(L"%lc", env[i]);
	}

	CloseHandle(hProcess);
	free(env);
}


int wmain(int argc, wchar_t** argv)
{
	if (argc != 2) {
		exit(1);
	}

	wchar_t* procName = argv[1];
	int pid = find_pid(procName);
	print_peb(pid);

	return 0;
}
