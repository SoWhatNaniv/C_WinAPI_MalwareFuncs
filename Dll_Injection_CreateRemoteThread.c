#include <windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


int main(int argc, char** argv)
{
	if (argc != 3) {
		printf("Usage Injector.exe <DLL Path> <EXE Path>");
		exit(1);
	}

	char* dll_path = argv[1];
	char* exe_path = argv[2];

	STARTUPINFO info = { sizeof(info) };
	PROCESS_INFORMATION processInfo = { sizeof(processInfo) };

	if (!CreateProcess(exe_path, NULL, NULL, NULL, NULL, CREATE_SUSPENDED, NULL, NULL, &info, &processInfo)) {
		printf("Cannot create process");
		exit(2);
	}

	PTHREAD_START_ROUTINE thread_start = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle("Kernel32.dll"), "LoadLibraryA");
	if (thread_start == NULL) {
		printf("Cannot get LoadLibrary address");
		exit(3);
	}

	LPVOID buffer = (LPVOID)VirtualAllocEx(processInfo.hProcess, NULL, strlen(dll_path), MEM_COMMIT, PAGE_READWRITE);
	if (buffer == NULL) {
		printf("Cannot allocate memory in remote process");
		exit(3);
	}

	if (WriteProcessMemory(processInfo.hProcess, buffer, (LPCVOID)dll_path, strlen(dll_path), NULL) == 0) {
		printf("Cannot write process to memory");
		exit(3);
	}

	HANDLE thread_handle = CreateRemoteThread(processInfo.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)thread_start, buffer, 0, NULL);
	if (!thread_handle) {
		printf("Cannot create a remote thread");
		exit(3);
	}

	if (ResumeThread(processInfo.hThread) == -1) {
		exit(3);
	}

	return 0;
}
