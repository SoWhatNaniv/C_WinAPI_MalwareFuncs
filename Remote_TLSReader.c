#include <windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <psapi.h>
#include <stdio.h>

typedef NTSTATUS(__stdcall* QueryInformationThreadFunc)(HANDLE, THREADINFOCLASS, PVOID, ULONG, PULONG);

HINSTANCE ntdllInstance;
QueryInformationThreadFunc NtQueryInformationThrea;

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PTEB TebBaseAddress;
	CLIENT_ID ClientId;
	ULONG_PTR AffinityMask;
	KPRIORITY Priority;
	LONG BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef struct _IMAGEPARAM {
	HMODULE ImageBase;
	DWORD SizeOfImage;
} IMAGEPARAM;

BOOL GetImageParameters(DWORD processID, IMAGEPARAM* img)
{
	BOOL return_value = FALSE;
	HMODULE hMod;
	MODULEINFO modinfo;
	DWORD cbNeeded;
	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE,
		processID);

	if (!hProcess) {
		return return_value;
	}

	if (!EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
		goto cleanup;
	}

	if (!GetModuleInformation(hProcess, hMod, &modinfo, sizeof(modinfo))) {
		goto cleanup;
	}

	img->ImageBase = hMod;
	img->SizeOfImage = modinfo.SizeOfImage;

	return_value = TRUE;
cleanup:
	CloseHandle(hProcess);
	return return_value;
}

int* find_all_pid(const char* procName) {
	int pid = NULL;
	int* temp_pid_arr;
	int pid_count = 1;
	int* pid_arr = (int*)calloc(pid_count, sizeof(int)); // PID ARRAY
	if (!pid_arr) {
		exit(1);
	}

	HANDLE handleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (handleSnapshot == INVALID_HANDLE_VALUE) {
		printf("Can't create a snapshot of the current system\r\n");
		return 1;
	}

	PROCESSENTRY32 processEntry = { 0 };
	processEntry.dwSize = sizeof(processEntry);

	if (Process32First(handleSnapshot, &processEntry)) {
		do {
			if (strcmp(processEntry.szExeFile, procName) == 0) {
				pid = processEntry.th32ProcessID;
				pid_arr[pid_count - 1] = pid;
				pid_count++;
				temp_pid_arr = (int*)realloc(pid_arr, pid_count * sizeof(int));
				if (!temp_pid_arr) {
					exit(1);
				}
				pid_arr = temp_pid_arr;
			}
		} while (Process32Next(handleSnapshot, &processEntry));
	}

	CloseHandle(handleSnapshot);

	pid_arr[pid_count - 1] = -1; // end of pid array

	return pid_arr;
}

THREADENTRY32* find_all_pids_threads(int* pid_arr) {


	int* pid = pid_arr;
	THREADENTRY32* temp_thread_arr;
	int thread_count = 1;
	THREADENTRY32* thread_arr = (THREADENTRY32*)calloc(thread_count, sizeof(THREADENTRY32)); // Thread Pointers Array
	if (!thread_arr) {
		exit(1);
	}

	HANDLE handleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);

	if (handleSnapshot == INVALID_HANDLE_VALUE) {
		printf("Can't create a snapshot of the current system\r\n");
		return 1;
	}

	// Allocate struct for threads iterating
	THREADENTRY32* ptrThread = (THREADENTRY32*)calloc(1, sizeof(THREADENTRY32));
	ptrThread->dwSize = sizeof(THREADENTRY32);

	while (*pid != 0) {

		if (Thread32First(handleSnapshot, ptrThread) != TRUE) {
			printf("Cannot get first thread \n");
			return 1;
		}
		do {
			// If the thread PID is equal to PID, add to list
			if (ptrThread->th32OwnerProcessID == *pid) {
				thread_arr[thread_count - 1] = *ptrThread;
				thread_count++;
				temp_thread_arr = (THREADENTRY32*)realloc(thread_arr, thread_count * sizeof(THREADENTRY32));
				if (!temp_thread_arr) {
					exit(1);
				}
				thread_arr = temp_thread_arr;
			}
		} while (Thread32Next(handleSnapshot, ptrThread) == TRUE);
		pid++;
	}

	thread_arr[thread_count - 1].th32ThreadID = 0; // end of threads array

	return thread_arr;
}

void print_threads_tls(THREADENTRY32* threads_ptr_arr) {

	NtQueryInformationThrea = (QueryInformationThreadFunc)GetProcAddress(LoadLibrary("ntdll.dll"), "NtQueryInformationThread");

	THREAD_BASIC_INFORMATION bi = { 0 };
	IMAGEPARAM img;

	if (GetImageParameters(threads_ptr_arr->th32OwnerProcessID, &img)) {

		int bytesRead;
		LPVOID buffer[64] = { 0 };

		while (threads_ptr_arr->th32ThreadID != 0) {
			// Query every thread
			HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, threads_ptr_arr->th32ThreadID);
			if (hThread == NULL) {
				exit(1);
			}
			NtQueryInformationThrea(hThread, (THREADINFOCLASS)0, &bi, sizeof(THREAD_BASIC_INFORMATION), NULL);
			if (bi.TebBaseAddress == NULL) {
				exit(1);
			}
			threads_ptr_arr++;
			CloseHandle(hThread);


			//thread parent process can change so the process handle will change (:
			HANDLE procHandle = OpenProcess(PROCESS_VM_READ, 0, threads_ptr_arr->th32OwnerProcessID);
			ReadProcessMemory(procHandle, (LPCVOID)(bi.TebBaseAddress->TlsSlots), (LPVOID*)buffer, 64 * sizeof(LPVOID), &bytesRead);
			CloseHandle(procHandle);

			for (int i = 0; i < 64; i++) {
				if (buffer[i] != 0) {
					printf("%p ", buffer[i]);
				}
			}
			printf("\n");

			memset(buffer, 0, sizeof(buffer));
		}
	}

}


int main(int argc, char** argv)
{
	if (argc != 2) {
		exit(1);
	}

	const char* procName = argv[1];
	int* pid_arr = find_all_pid(procName);  // Get PID's by name
	THREADENTRY32* threads_ptr_arr = find_all_pids_threads(pid_arr); // Get all Threads by PID's

	print_threads_tls(threads_ptr_arr);

	free(pid_arr);
	free(threads_ptr_arr);

	return 0;
}
