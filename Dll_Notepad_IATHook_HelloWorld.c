// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>

int hello_world_counter = 0;
int hello_world[] = { 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100 };

int hooking(char* api1);

LRESULT HookedDispatchMessage(const MSG* lpMsg);

INT APIENTRY DllMain(HMODULE hDLL, DWORD Reason, LPVOID Reserved) {

	char* api1 = "DispatchMessageW";
	switch (Reason) {
	case DLL_PROCESS_ATTACH:
		hooking(api1);
		break;
	case DLL_PROCESS_DETACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	}
	return TRUE;
}

// this func called for start the hooking
int hooking(char * nameOfAPIone) {

	DWORD baseAddress = (DWORD)GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
	PIMAGE_NT_HEADERS peHeader = (PIMAGE_NT_HEADERS)(baseAddress + (*dosHeader).e_lfanew);
	IMAGE_OPTIONAL_HEADER32 optionalHeader = (*peHeader).OptionalHeader;
	IMAGE_DATA_DIRECTORY importDirectory = (optionalHeader).DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
		(importDirectory.VirtualAddress + baseAddress);

	int i = 0;

	while (importDescriptor[i].Characteristics != 0) {
		PIMAGE_THUNK_DATA thunkINT = (PIMAGE_THUNK_DATA)
			(importDescriptor[i].OriginalFirstThunk + baseAddress);;
		PIMAGE_THUNK_DATA thunkIAT = (PIMAGE_THUNK_DATA)
			(importDescriptor[i].FirstThunk + baseAddress);

		DWORD CurrentProtect;
		PIMAGE_IMPORT_BY_NAME nameData;

		while ((*thunkINT).u1.AddressOfData != 0) {
			if (!((*thunkINT).u1.Ordinal & IMAGE_ORDINAL_FLAG)) {
				nameData = (PIMAGE_IMPORT_BY_NAME)((*thunkINT).u1.AddressOfData + baseAddress);

				if (strcmp(nameOfAPIone, (*nameData).Name) == 0) {
					VirtualProtect(thunkIAT, 4096, PAGE_READWRITE, &CurrentProtect);
					thunkIAT->u1.Function = (DWORD)&HookedDispatchMessage;
					MessageBox(NULL,(LPCWSTR)L"Injected1", (LPCWSTR)L"Injected1", MB_OK);
				}
			}
			thunkINT++;
			thunkIAT++;
		}
		i++;
	}

	return TRUE;
}

LRESULT HookedDispatchMessage(const MSG* lpMsg) {
	MSG* templpMsg = lpMsg;
	if (lpMsg->message == 0x102) {
		templpMsg->wParam = hello_world[hello_world_counter % 11];
		hello_world_counter += 1;
	}
	return DispatchMessageW(lpMsg);
}
